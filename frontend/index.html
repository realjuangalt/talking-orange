<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>Talking Orange AR</title>
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    <style>
        /* Mobile-friendly styles */
        @media (max-width: 768px) {
            #ask-question-btn {
                padding: 12px 24px !important;
                font-size: 14px !important;
                min-width: 180px !important;
            }
            
            .language-toggle, .debug-controls {
                padding: 6px !important;
                font-size: 11px !important;
            }
            
            .language-toggle label {
                font-size: 11px !important;
                margin-right: 6px !important;
            }
            
            .language-toggle select {
                padding: 3px 6px !important;
                font-size: 11px !important;
            }
        }
        
        @media (max-width: 480px) {
            #ask-question-btn {
                padding: 10px 20px !important;
                font-size: 13px !important;
                min-width: 160px !important;
                bottom: 15px !important;
            }
            
            .language-toggle, .debug-controls {
                padding: 4px !important;
                font-size: 10px !important;
            }
        }
        
        /* Prevent zoom on double tap */
        * {
            touch-action: manipulation;
        }
        
        /* Ensure buttons are touch-friendly */
        button {
            min-height: 44px;
            min-width: 44px;
        }
    </style>
</head>
<body>
    <a-scene mindar-image="imageTargetSrc: ./targets.mind; maxTrack: 1; uiLoading: yes; uiScanning: yes; uiError: yes;" vr-mode-ui="enabled: false" device-orientation-permission-ui="enabled: false" renderer="antialias: true; physicallyCorrectLights: true">
        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
        <a-assets>
            <img id="talking-orange" src="./talking-orange-smile.png" />
            <img id="talking-orange-open-mouth" src="./talking-orange-open-mouth.png" />
            <img id="talking-orange-half-open-mouth" src="./talking-orange-half-open-mouth.png" />
            <img id="talking-orange-thinking-1" src="./talking-orange-thinking-1.png" />
            <img id="talking-orange-thinking-2" src="./talking-orange-thinking-2.png" />
        </a-assets>
        
        <a-entity mindar-image-target="targetIndex: 0">
            <!-- Project the talking orange image as a plane overlay with smoothing -->
            <a-plane id="talking-orange-plane" src="#talking-orange" position="0 0 0.01" height="1" width="1" rotation="9 0 0" 
                     material="transparent: true; alphaTest: 0.1; opacity: 1"
                     animation="property: position; to: 0 0 0.01; dur: 300; easing: easeInOutQuad; loop: true; dir: alternate"></a-plane>
            
            <!-- Additional 3D objects with smoothing (cube removed) -->
           
            <a-text value="TALKING ORANGE" position="0 1.5 0" color="orange" align="center" 
                    animation="property: position; to: 0 1.5 0; dur: 300; easing: easeInOutQuad; loop: true; dir: alternate"></a-text>
        </a-entity>
    </a-scene>
    
    <!-- Language Toggle -->
    <div style="position: fixed; top: 15px; right: 15px; z-index: 1000;">
        <button id="language-toggle" onclick="toggleLanguage()" 
                style="background: rgba(0,0,0,0.3); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 6px 12px; border-radius: 15px; cursor: pointer; font-size: 12px; font-weight: bold; backdrop-filter: blur(5px);">
            EN
        </button>
    </div>
    
    <!-- Main Ask Question Button (bottom center) -->
    <div style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
        <button id="ask-question-btn" onclick="window.askQuestion()" 
                style="background: #2196F3; color: white; border: none; padding: 15px 30px; border-radius: 25px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 4px 8px rgba(0,0,0,0.3); min-width: 200px;">
            Ask Question
        </button>
    </div>
    
    <script>
        console.log('üîç MindAR Local Test - Using YOUR targets.mind file');
        
        document.addEventListener('DOMContentLoaded', function() {
            const scene = document.querySelector('a-scene');
            const marker = document.querySelector('[mindar-image-target]');
            const orangePlane = document.querySelector('#talking-orange-plane');
            
            console.log('üîç Scene:', scene);
            console.log('üîç Marker:', marker);
            console.log('üîç Orange Plane:', orangePlane);
            
            // ========================================
            // TALKING ANIMATION MODULE
            // ========================================
            class TalkingAnimationModule {
                constructor(orangePlane) {
                    this.orangePlane = orangePlane;
                    this.idleState = { id: '#talking-orange', name: 'smile', src: './talking-orange-smile.png' };
                    this.talkingStates = [
                        { id: '#talking-orange-half-open-mouth', name: 'half-open', src: './talking-orange-half-open-mouth.png' },
                        { id: '#talking-orange-open-mouth', name: 'wide-open', src: './talking-orange-open-mouth.png' }
                    ];
                    this.thinkingStates = [
                        { id: '#talking-orange-thinking-1', name: 'thinking-1', src: './talking-orange-thinking-1.png' },
                        { id: '#talking-orange-thinking-2', name: 'thinking-2', src: './talking-orange-thinking-2.png' }
                    ];
                    this.currentTalkingState = 0;
                    this.currentThinkingState = 0;
                    this.isTalking = false;
                    this.isThinking = false;
                    this.talkingInterval = null;
                    this.thinkingInterval = null;
                    this.debugMode = true;
                    this.isIdle = true;
                    
                    this.init();
                }
                
                init() {
                    console.log('üé≠ Initializing Talking Animation Module');
                    this.debugImageLoading();
                    this.preprocessImages();
                    // Removed testAllMouthStates() - animation only happens during voice playback
                }
                
                preprocessImages() {
                    console.log('üîß Preprocessing images for consistent dimensions...');
                    
                    // Find the reference dimensions (use the transparent PNG as reference)
                    const referenceImg = document.querySelector('img[id="talking-orange"]');
                    if (!referenceImg) {
                        console.error('‚ùå Reference image not found');
                        return;
                    }
                    
                    const refWidth = referenceImg.naturalWidth;
                    const refHeight = referenceImg.naturalHeight;
                    
                    console.log(`üìè Reference dimensions: ${refWidth}x${refHeight}`);
                    
                    // Check idle state (closed mouth)
                    console.log(`üñºÔ∏è Idle state (${this.idleState.name}): ${refWidth}x${refHeight}`);
                    
                    // Process talking states
                    this.talkingStates.forEach((state, index) => {
                        const img = document.querySelector(`img[id="${state.id.replace('#', '')}"]`);
                        if (img) {
                            const currentWidth = img.naturalWidth;
                            const currentHeight = img.naturalHeight;
                            
                            console.log(`üñºÔ∏è Talking state ${index + 1} (${state.name}): ${currentWidth}x${currentHeight}`);
                            
                            if (currentWidth !== refWidth || currentHeight !== refHeight) {
                                console.log(`‚ö†Ô∏è Dimension mismatch detected for ${state.name}`);
                                console.log(`   Expected: ${refWidth}x${refHeight}, Got: ${currentWidth}x${currentHeight}`);
                            }
                        }
                    });
                }
                
                debugImageLoading() {
                    console.log('üîç Debugging image loading...');
                    
                    // Check idle state
                    const idleImg = document.querySelector(`img[id="${this.idleState.id.replace('#', '')}"]`);
                    if (idleImg) {
                        console.log(`‚úÖ Idle image (${this.idleState.name}):`, {
                            id: this.idleState.id,
                            src: this.idleState.src,
                            loaded: idleImg.complete,
                            naturalWidth: idleImg.naturalWidth,
                            naturalHeight: idleImg.naturalHeight
                        });
                    }
                    
                    // Check talking states
                    this.talkingStates.forEach((state, index) => {
                        const img = document.querySelector(`img[id="${state.id.replace('#', '')}"]`);
                        if (img) {
                            console.log(`‚úÖ Talking image ${index + 1} (${state.name}):`, {
                                id: state.id,
                                src: state.src,
                                loaded: img.complete,
                                naturalWidth: img.naturalWidth,
                                naturalHeight: img.naturalHeight
                            });
                            
                            // Add load event listener
                            img.addEventListener('load', () => {
                                console.log(`üñºÔ∏è Image loaded successfully: ${state.name}`);
                            });
                            
                            img.addEventListener('error', () => {
                                console.error(`‚ùå Image failed to load: ${state.name} (${state.src})`);
                            });
                        } else {
                            console.error(`‚ùå Image element not found: ${state.id}`);
                        }
                    });
                }
                
                resetMaterialProperties() {
                    try {
                        console.log('üîÑ Resetting material properties...');
                        const material = this.orangePlane.getObject3D('mesh').material;
                        
                        // Reset material properties to prevent color degradation
                        material.opacity = 1.0;
                        material.transparent = true;
                        material.alphaTest = 0.1;
                        
                        // Safely reset color properties
                        if (material.color) material.color.setHex(0xffffff); // Reset to white
                        if (material.emissive) material.emissive.setHex(0x000000); // Reset emissive
                        if (material.specular) material.specular.setHex(0x111111); // Reset specular
                        
                        // Ensure no color filters are applied
                        if (material.map) {
                            material.map.colorSpace = THREE.SRGBColorSpace;
                        }
                        
                        material.needsUpdate = true;
                        console.log('‚úÖ Material properties reset');
                        
                    } catch (error) {
                        console.error('‚ùå Error resetting material properties:', error);
                    }
                }
                
                
                setToIdleState() {
                    console.log('üé≠ Setting to idle state (closed mouth)');
                    this.isIdle = true;
                    this.resetMaterialProperties();
                    this.applyTextureFromState(this.idleState);
                    
                    // Fix upside down smile image by adjusting rotation
                    this.orangePlane.setAttribute('rotation', '9 0 180');
                }
                
                setToTalkingState(stateIndex) {
                    if (stateIndex < 0 || stateIndex >= this.talkingStates.length) {
                        console.error(`‚ùå Invalid talking state index: ${stateIndex}`);
                        return;
                    }
                    
                    const state = this.talkingStates[stateIndex];
                    this.currentTalkingState = stateIndex;
                    this.isIdle = false;
                    
                    console.log(`üé≠ Setting to talking state: ${state.name} (${state.id})`);
                    this.applyTextureFromState(state);
                    
                    // Fix upside down talking images by adjusting rotation
                    this.orangePlane.setAttribute('rotation', '9 0 180');
                }
                
                applyTextureFromState(state) {
                    // Get the image element
                    const img = document.querySelector(`img[id="${state.id.replace('#', '')}"]`);
                    if (!img) {
                        console.error(`‚ùå Image not found: ${state.id}`);
                        return;
                    }
                    
                    // Recreate material with the new image
                    this.recreateMaterial(img);
                }
                
                recreateMaterial(img) {
                    try {
                        console.log('üîÑ Recreating material for texture change...');
                        
                        // Get reference dimensions
                        const referenceImg = document.querySelector('img[id="talking-orange"]');
                        const refWidth = referenceImg.naturalWidth;
                        const refHeight = referenceImg.naturalHeight;
                        
                        // Check if resizing is needed
                        if (img.naturalWidth !== refWidth || img.naturalHeight !== refHeight) {
                            console.log('üîÑ Image dimensions mismatch, resizing...');
                            
                            // Resize image to match reference
                            const resizedDataURL = this.resizeImageToCanvas(img, refWidth, refHeight);
                            if (resizedDataURL) {
                                // Create new image with resized data
                                const resizedImg = new Image();
                                resizedImg.onload = () => {
                                    this.applyTextureToMaterial(resizedImg);
                                };
                                resizedImg.src = resizedDataURL;
                                return;
                            }
                        }
                        
                        // Use original image if no resizing needed
                        this.applyTextureToMaterial(img);
                        
                    } catch (error) {
                        console.error('‚ùå Error recreating material:', error);
                        
                        // Fallback: Try the old method
                        console.log('üîÑ Trying fallback method...');
                        this.orangePlane.setAttribute('src', img.id);
                    }
                }
                
                resizeImageToCanvas(img, targetWidth, targetHeight) {
                    try {
                        console.log(`üîÑ Resizing image to ${targetWidth}x${targetHeight}...`);
                        
                        // Create canvas
                        const canvas = document.createElement('canvas');
                        canvas.width = targetWidth;
                        canvas.height = targetHeight;
                        const ctx = canvas.getContext('2d');
                        
                        // Draw resized image
                        ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
                        
                        // Convert to data URL
                        const dataURL = canvas.toDataURL('image/png');
                        
                        console.log('‚úÖ Image resized successfully');
                        return dataURL;
                        
                    } catch (error) {
                        console.error('‚ùå Error resizing image:', error);
                        return null;
                    }
                }
                
                applyTextureToMaterial(img) {
                    try {
                        console.log('üîÑ Applying texture to material...');
                        
                        // Get the current material
                        const material = this.orangePlane.getObject3D('mesh').material;
                        
                        // Dispose of the old texture to prevent memory leaks
                        if (material.map) {
                            material.map.dispose();
                        }
                        
                        // Create a new texture from the image
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        texture.colorSpace = THREE.SRGBColorSpace; // Ensure correct color space
                        texture.flipY = false; // Prevent texture flipping
                        
                        // Update the material's map
                        material.map = texture;
                        material.needsUpdate = true;
                        
                        // Force material update
                        this.orangePlane.getObject3D('mesh').material = material;
                        
                        console.log('‚úÖ Material updated successfully');
                        
                    } catch (error) {
                        console.error('‚ùå Error applying texture:', error);
                        
                        // Fallback: Try the old method
                        console.log('üîÑ Trying fallback method...');
                        this.orangePlane.setAttribute('src', img.id);
                    }
                }
                
                startTalkingAnimation() {
                    if (this.isTalking) {
                        console.log('‚ö†Ô∏è Animation already running');
                        return;
                    }
                    
                    this.isTalking = true;
                    console.log('üó£Ô∏è Starting talking animation (loop between half-open and open)');
                    
                    // Start cycling between half-open and open mouth
                    this.talkingInterval = setInterval(() => {
                        const nextState = (this.currentTalkingState + 1) % this.talkingStates.length;
                        this.setToTalkingState(nextState);
                    }, 200); // Change mouth every 200ms
                }
                
                stopTalkingAnimation() {
                    if (!this.isTalking) {
                        console.log('‚ö†Ô∏è Animation not running');
                        return;
                    }
                    
                    this.isTalking = false;
                    console.log('üîá Stopping talking animation, returning to idle');
                    
                    if (this.talkingInterval) {
                        clearInterval(this.talkingInterval);
                        this.talkingInterval = null;
                    }
                    
                    // Return to closed mouth (idle state)
                    this.setToIdleState();
                }
                
                startThinkingAnimation() {
                    if (this.isThinking) {
                        console.log('‚ö†Ô∏è Thinking animation already running');
                        return;
                    }
                    
                    console.log('ü§î Starting thinking animation...');
                    this.isThinking = true;
                    this.isIdle = false;
                    
                    // Cycle through thinking states
                    this.thinkingInterval = setInterval(() => {
                        this.setToThinkingState(this.currentThinkingState);
                        this.currentThinkingState = (this.currentThinkingState + 1) % this.thinkingStates.length;
                    }, 800); // Slower than talking animation
                }
                
                stopThinkingAnimation() {
                    if (!this.isThinking) {
                        console.log('‚ö†Ô∏è No thinking animation running');
                        return;
                    }
                    
                    console.log('üõë Stopping thinking animation...');
                    this.isThinking = false;
                    
                    if (this.thinkingInterval) {
                        clearInterval(this.thinkingInterval);
                        this.thinkingInterval = null;
                    }
                    
                    console.log('‚úÖ Thinking animation stopped');
                }
                
                setToThinkingState(stateIndex) {
                    if (stateIndex < 0 || stateIndex >= this.thinkingStates.length) {
                        console.error(`‚ùå Invalid thinking state index: ${stateIndex}`);
                        return;
                    }
                    
                    const state = this.thinkingStates[stateIndex];
                    console.log(`ü§î Setting to thinking state: ${state.name} (${state.id})`);
                    
                    // Apply texture
                    this.applyTextureFromState(state);
                    
                    // Fix upside down thinking images by adjusting rotation
                    this.orangePlane.setAttribute('rotation', '9 0 180'); // Flip 180 degrees
                }
                
                getStatus() {
                    return {
                        isTalking: this.isTalking,
                        isThinking: this.isThinking,
                        isIdle: this.isIdle,
                        currentTalkingState: this.currentTalkingState,
                        currentThinkingState: this.currentThinkingState,
                        currentStateName: this.isIdle ? this.idleState.name : 
                                        this.isThinking ? this.thinkingStates[this.currentThinkingState].name :
                                        this.talkingStates[this.currentTalkingState].name,
                        planeSrc: this.orangePlane.getAttribute('src')
                    };
                }
            }
            
            // Initialize the animation module
            const animationModule = new TalkingAnimationModule(orangePlane);
            
            // Expose functions for external control
            function startTalkingAnimation() {
                animationModule.startTalkingAnimation();
            }
            
            function stopTalkingAnimation() {
                animationModule.stopTalkingAnimation();
            }
            
            function startThinkingAnimation() {
                animationModule.startThinkingAnimation();
            }
            
            function stopThinkingAnimation() {
                animationModule.stopThinkingAnimation();
            }
            
            // Voice recording and processing system
            let mediaRecorder = null;
            let audioChunks = [];
            let isRecording = false;
            let recordingTimer = null;
            let recordingStartTime = null;
            
            async function askQuestion() {
                if (isRecording) {
                    console.log('Stopping recording...');
                    stopRecording();
                    return;
                }
                
                try {
                    console.log('üé§ Starting voice recording...');
                    
                    // Request microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    
                    // Set up MediaRecorder
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    
                    mediaRecorder.ondataavailable = function(event) {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                            console.log(`üì¶ Collected audio chunk: ${event.data.size} bytes`);
                        }
                    };
                    
                    mediaRecorder.onstop = async function() {
                        console.log('üîä Recording stopped, processing audio...');
                        console.log(`üìä Total chunks collected: ${audioChunks.length}`);
                        
                        // Create audio blob
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        console.log(`üìä Total audio blob size: ${audioBlob.size} bytes`);
                        
                        // Convert to base64
                        const reader = new FileReader();
                        reader.onloadend = async function() {
                            const base64Audio = reader.result.split(',')[1]; // Remove data:audio/webm;base64, prefix
                            console.log(`üì§ Sending audio data: ${base64Audio.length} characters`);
                            
                            // Send to backend for processing
                            await processVoiceInput(base64Audio);
                        };
                        reader.readAsDataURL(audioBlob);
                        
                        // Stop all tracks
                        stream.getTracks().forEach(track => track.stop());
                    };
                    
                    // Start recording with timeslice to ensure we capture all data
                    mediaRecorder.start(1000); // Request data every 1 second
                    isRecording = true;
                    recordingStartTime = Date.now();
                    
                    // Show recording indicator
                    const button = document.getElementById('ask-question-btn');
                    button.textContent = currentLanguage === 'es' ? 'Detener Grabaci√≥n (0s)' : 'Stop Recording (0s)';
                    button.style.background = '#f44336';
                    
                    // Update timer every second
                    recordingTimer = setInterval(() => {
                        if (isRecording) {
                            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                            button.textContent = currentLanguage === 'es' ? `Detener Grabaci√≥n (${elapsed}s)` : `Stop Recording (${elapsed}s)`;
                            
                            // Auto-stop after 1 minute (60 seconds)
                            if (elapsed >= 60) {
                                console.log('‚è∞ Auto-stopping recording after 1 minute');
                                stopRecording();
                            }
                        }
                    }, 1000);
                    
                } catch (error) {
                    console.error('‚ùå Error accessing microphone:', error);
                    alert('Error accessing microphone. Please check permissions.');
                }
            }
            
            function stopRecording() {
                if (mediaRecorder && isRecording) {
                    console.log('üõë Stopping recording...');
                    isRecording = false;
                    
                    // Clear the timer
                    if (recordingTimer) {
                        clearInterval(recordingTimer);
                        recordingTimer = null;
                    }
                    
                    // Request final data before stopping
                    mediaRecorder.requestData();
                    
                    // Stop the recorder (this will trigger onstop)
                    mediaRecorder.stop();
                    
                    // Reset button
                    const button = document.getElementById('ask-question-btn');
                    updateButtonText(); // Use the dynamic text function
                    button.style.background = '#2196F3';
                    
                    // Start thinking animation while processing
                    console.log('ü§î Starting thinking animation...');
                    startThinkingAnimation();
                }
            }
            
            async function processVoiceInput(audioData) {
                try {
                    console.log('üì§ Sending audio to backend...');
                    
                    const response = await fetch('/api/speech/process', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            audioData: audioData,
                            sessionId: 'web_session_' + Date.now(),
                            language: currentLanguage,
                            ttsVoice: 'default',
                            ttsEngine: 'auto'
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    console.log('‚úÖ Voice processing result:', result);
                    
                    // Play the audio response
                    if (result.audioUrl) {
                        await playAudioResponse(result.audioUrl);
                    }
                    
                    // Show transcription and response
                    console.log('üìù Transcription:', result.transcription);
                    console.log('üí¨ Response:', result.response);
                    
                } catch (error) {
                    console.error('‚ùå Voice processing error:', error);
                    alert('Error processing voice input: ' + error.message);
                }
            }
            
            async function playAudioResponse(audioUrl) {
                try {
                    console.log('üîä Playing audio response:', audioUrl);
                    
                    // Stop thinking animation and start talking animation
                    stopThinkingAnimation();
                    startTalkingAnimation();
                    
                    const audio = new Audio(audioUrl);
                    
                    // Stop animation when audio ends
                    audio.onended = function() {
                        console.log('‚úÖ Audio playback completed, stopping talking animation');
                        stopTalkingAnimation();
                    };
                    
                    // Also handle errors
                    audio.onerror = function() {
                        console.error('‚ùå Audio playback error, stopping animation');
                        stopTalkingAnimation();
                    };
                    
                    await audio.play();
                    
                } catch (error) {
                    console.error('‚ùå Audio playback error:', error);
                    // Stop animation on error
                    stopTalkingAnimation();
                }
            }
            
            // Debug function
            function debugAnimation() {
                console.log('üîç Animation Debug Report');
                console.log('========================');
                console.log('Animation Module Status:', animationModule.getStatus());
                console.log('Orange Plane Element:', orangePlane);
                console.log('Orange Plane Attributes:', {
                    src: orangePlane.getAttribute('src'),
                    position: orangePlane.getAttribute('position'),
                    rotation: orangePlane.getAttribute('rotation'),
                    material: orangePlane.getAttribute('material')
                });
                
                // Manual testing - only when debug button is clicked
                console.log('üß™ Manual animation state testing...');
                console.log('Testing idle state (smile)');
                animationModule.setToIdleState();
                
                setTimeout(() => {
                    console.log('Testing thinking states');
                    animationModule.thinkingStates.forEach((state, index) => {
                        setTimeout(() => {
                            console.log(`Testing thinking state ${index + 1}: ${state.name}`);
                            animationModule.setToThinkingState(index);
                        }, index * 1000);
                    });
                    
                    setTimeout(() => {
                        console.log('Testing talking states');
                        animationModule.talkingStates.forEach((state, index) => {
                            setTimeout(() => {
                                console.log(`Testing talking state ${index + 1}: ${state.name}`);
                                animationModule.setToTalkingState(index);
                            }, index * 1000);
                        });
                        
                        // Return to idle after testing
                        setTimeout(() => {
                            animationModule.setToIdleState();
                            console.log('‚úÖ Debug test completed - returned to idle');
                        }, 3000);
                    }, 2000);
                }, 1000);
            }
            
            // Language toggle functionality
            let currentLanguage = 'en';
            
            function toggleLanguage() {
                currentLanguage = currentLanguage === 'en' ? 'es' : 'en';
                const button = document.getElementById('language-toggle');
                button.textContent = currentLanguage.toUpperCase();
                updateButtonText();
            }
            
            function updateButtonText() {
                const button = document.getElementById('ask-question-btn');
                
                if (currentLanguage === 'es') {
                    button.textContent = 'Hacer Pregunta';
                } else {
                    button.textContent = 'Ask Question';
                }
            }
            
            // Initialize button text
            updateButtonText();
            
            // Expose functions globally for external control
            window.startTalkingAnimation = startTalkingAnimation;
            window.stopTalkingAnimation = stopTalkingAnimation;
            window.startThinkingAnimation = startThinkingAnimation;
            window.stopThinkingAnimation = stopThinkingAnimation;
            window.askQuestion = askQuestion;
            window.animationModule = animationModule; // Expose for console debugging
            
            if (marker) {
                // Add smoothing variables
                let lastPosition = { x: 0, y: 0, z: 0 };
                let smoothingFactor = 0.05; // Much more aggressive smoothing
                let positionHistory = [];
                const maxHistoryLength = 5;
                
                marker.addEventListener('targetFound', function() {
                    console.log('üéØ Target found! Red cube and blue sphere should be visible');
                });
                marker.addEventListener('targetLost', function() {
                    console.log('‚ùå Target lost');
                });
                
                // Add smoothing to marker position
                marker.addEventListener('componentchanged', function(event) {
                    if (event.detail.name === 'position') {
                        const currentPos = marker.getAttribute('position');
                        if (currentPos) {
                            // Add to position history
                            positionHistory.push({
                                x: parseFloat(currentPos.x),
                                y: parseFloat(currentPos.y),
                                z: parseFloat(currentPos.z)
                            });
                            
                            // Keep only recent positions
                            if (positionHistory.length > maxHistoryLength) {
                                positionHistory.shift();
                            }
                            
                            // Calculate average position
                            const avgPos = {
                                x: positionHistory.reduce((sum, pos) => sum + pos.x, 0) / positionHistory.length,
                                y: positionHistory.reduce((sum, pos) => sum + pos.y, 0) / positionHistory.length,
                                z: positionHistory.reduce((sum, pos) => sum + pos.z, 0) / positionHistory.length
                            };
                            
                            // Apply additional smoothing
                            const smoothedPos = {
                                x: lastPosition.x + (avgPos.x - lastPosition.x) * smoothingFactor,
                                y: lastPosition.y + (avgPos.y - lastPosition.y) * smoothingFactor,
                                z: lastPosition.z + (avgPos.z - lastPosition.z) * smoothingFactor
                            };
                            
                            lastPosition = smoothedPos;
                            marker.setAttribute('position', `${smoothedPos.x} ${smoothedPos.y} ${smoothedPos.z}`);
                        }
                    }
                });
            }
            
            // Check for MindAR system
            setTimeout(() => {
                if (scene && scene.systems && scene.systems['mindar-image-system']) {
                    console.log('‚úÖ MindAR system found:', scene.systems['mindar-image-system']);
                } else {
                    console.log('‚ùå MindAR system not found');
                    console.log('üîç Available systems:', scene.systems ? Object.keys(scene.systems) : 'No systems');
                }
            }, 3000);
        });
    </script>
</body>
</html>
