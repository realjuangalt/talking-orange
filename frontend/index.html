<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>Talking Orange AR</title>
    <script src="./lib/aframe.min.js"></script>
    <script src="./lib/mindar-image-aframe.prod.js"></script>
    <style>
        /* Mobile-friendly styles */
        @media (max-width: 768px) {
            #ask-question-btn {
                padding: 12px 24px !important;
                font-size: 14px !important;
                min-width: 180px !important;
            }
            
            .language-toggle, .debug-controls {
                padding: 6px !important;
                font-size: 11px !important;
            }
            
            .language-toggle label {
                font-size: 11px !important;
                margin-right: 6px !important;
            }
            
            .language-toggle select {
                padding: 3px 6px !important;
                font-size: 11px !important;
            }
        }
        
        @media (max-width: 480px) {
            #ask-question-btn {
                padding: 10px 20px !important;
                font-size: 13px !important;
                min-width: 160px !important;
                bottom: 15px !important;
            }
            
            .language-toggle, .debug-controls {
                padding: 4px !important;
                font-size: 10px !important;
            }
        }
        
        /* Prevent zoom on double tap */
        * {
            touch-action: manipulation;
        }
        
        /* Ensure buttons are touch-friendly */
        button {
            min-height: 44px;
            min-width: 44px;
        }
    </style>
</head>
<body>
    <a-scene mindar-image="imageTargetSrc: ./media/targets.mind; maxTrack: 1; uiLoading: yes; uiScanning: yes; uiError: yes;" vr-mode-ui="enabled: false" device-orientation-permission-ui="enabled: false" renderer="antialias: true; physicallyCorrectLights: false">
        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
        <a-assets>
            <!-- Images for idle state -->
            <img id="talking-orange" src="./media/talking-orange-smile.png" />
            <!-- Images for thinking state -->

            <img id="talking-orange-thinking-1" src="./media/talking-orange-thinking-1.png" />
            <img id="talking-orange-thinking-2" src="./media/talking-orange-thinking-2.png" />
            
            <!-- Images for talking animation (mouth opening/closing) -->
            <img id="talking-orange-talking-1" src="./media/talking-orange-talking-1.png" />
            <img id="talking-orange-talking-2" src="./media/talking-orange-talking-2.png" />
        </a-assets>
        
        <a-entity mindar-image-target="targetIndex: 0">
            <!-- Image plane for all states (idle, thinking, talking) -->
            <a-plane id="talking-orange-plane" src="#talking-orange" position="0 0 0.01" height="1" width="1" rotation="9 0 0" 
                     material="shader: flat; transparent: true; alphaTest: 0.1; opacity: 1"
                     animation="property: position; to: 0 0 0.01; dur: 300; easing: easeInOutQuad; loop: true; dir: alternate"></a-plane>
        </a-entity>
    </a-scene>
    
    <!-- Language Toggle -->
    <div style="position: fixed; top: 15px; right: 15px; z-index: 1000;">
        <button id="language-toggle" onclick="toggleLanguage()" 
                style="background: rgba(0,0,0,0.3); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 6px 12px; border-radius: 15px; cursor: pointer; font-size: 12px; font-weight: bold; backdrop-filter: blur(5px);">
            EN
        </button>
    </div>
    
    <!-- Main Ask Question Button (bottom center) -->
    <div style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">
        <button id="ask-question-btn" onclick="window.askQuestion()" 
                style="background: #2196F3; color: white; border: none; padding: 15px 30px; border-radius: 25px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 4px 8px rgba(0,0,0,0.3); min-width: 200px;">
            Ask Question
        </button>
    </div>
    
    <script>
        console.log('üîç MindAR Local Test - Using YOUR targets.mind file');
        
        document.addEventListener('DOMContentLoaded', function() {
            const scene = document.querySelector('a-scene');
            const marker = document.querySelector('[mindar-image-target]');
            const orangePlane = document.querySelector('#talking-orange-plane');
            
            console.log('üîç Scene:', scene);
            console.log('üîç Marker:', marker);
            console.log('üîç Orange Plane:', orangePlane);
            
            // ========================================
            // TALKING ANIMATION MODULE
            // ========================================
            class TalkingAnimationModule {
                constructor(orangePlane) {
                    this.orangePlane = orangePlane;
                    
                    this.idleState = { id: '#talking-orange', name: 'smile', src: './media/talking-orange-smile.png' };
                    this.thinkingStates = [
                        { id: '#talking-orange-thinking-1', name: 'thinking-1', src: './media/talking-orange-thinking-1.png' },
                        { id: '#talking-orange-thinking-2', name: 'thinking-2', src: './media/talking-orange-thinking-2.png' }
                    ];
                    
                    // Load talking states dynamically (sorted by number: 1, 2, 3, etc.)
                    this.talkingStates = this.loadTalkingStates();
                    
                    this.currentThinkingState = 0;
                    this.currentTalkingState = 0;
                    this.talkingDirection = 1; // 1 = forward (opening), -1 = backward (closing)
                    this.isTalking = false;
                    this.isThinking = false;
                    this.talkingInterval = null;
                    this.thinkingInterval = null;
                    this.debugMode = true;
                    this.isIdle = true;
                    
                    this.init();
                }
                
                init() {
                    console.log('üé≠ Initializing Talking Animation Module');
                    this.debugImageLoading();
                }
                
                loadTalkingStates() {
                    // Dynamically load all talking images (talking-orange-talking-N.png)
                    // They're already in assets, we just need to create state objects
                    const states = [];
                    let index = 1;
                    
                    while (true) {
                        const imgElement = document.querySelector(`img[id="talking-orange-talking-${index}"]`);
                        if (imgElement) {
                            states.push({
                                id: `#talking-orange-talking-${index}`,
                                name: `talking-${index}`,
                                src: `./media/talking-orange-talking-${index}.png`
                            });
                            index++;
                        } else {
                            break;
                        }
                    }
                    
                    console.log(`‚úÖ Loaded ${states.length} talking animation states:`, states.map(s => s.name));
                    return states;
                }
                
                setToTalkingState(stateIndex) {
                    if (stateIndex < 0 || stateIndex >= this.talkingStates.length) {
                        console.error(`‚ùå Invalid talking state index: ${stateIndex}`);
                        return;
                    }
                    
                    const state = this.talkingStates[stateIndex];
                    console.log(`üó£Ô∏è Setting to talking state: ${state.name}`);
                    this.applyTextureFromState(state);
                }
                
                debugImageLoading() {
                    console.log('üîç Debugging image loading...');
                    
                    // Check idle state
                    const idleImg = document.querySelector(`img[id="${this.idleState.id.replace('#', '')}"]`);
                    if (idleImg) {
                        console.log(`‚úÖ Idle image (${this.idleState.name}):`, {
                            id: this.idleState.id,
                            src: this.idleState.src,
                            loaded: idleImg.complete
                        });
                    }
                }
                
                setToIdleState() {
                    console.log('üé≠ Setting to idle state (smile)');
                    this.isIdle = true;
                    
                    // Show image plane
                    const imageMesh = this.orangePlane.getObject3D('mesh');
                    if (imageMesh) {
                        imageMesh.visible = true;
                    }
                    
                    // Show smile image
                    this.applyTextureFromState(this.idleState);
                }
                
                applyTextureFromState(state) {
                    const img = document.querySelector(`img[id="${state.id.replace('#', '')}"]`);
                    if (!img) {
                        console.error(`‚ùå Image not found: ${state.id}`);
                        return;
                    }
                    
                    this.recreateMaterial(img);
                }
                
                recreateMaterial(img) {
                    try {
                        const mesh = this.orangePlane.getObject3D('mesh');
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        texture.colorSpace = THREE.SRGBColorSpace;
                        texture.flipY = true;
                        
                        // Use MeshBasicMaterial - doesn't respond to lighting (no shading)
                        const material = new THREE.MeshBasicMaterial({
                            map: texture,
                            transparent: true,
                            alphaTest: 0.1,
                            opacity: 1.0,
                            side: THREE.DoubleSide
                        });
                        
                        // Dispose old material if it exists
                        if (mesh.material && mesh.material.map) {
                            mesh.material.map.dispose();
                            mesh.material.dispose();
                        }
                        
                        mesh.material = material;
                        
                    } catch (error) {
                        console.error('‚ùå Error recreating material:', error);
                        this.orangePlane.setAttribute('src', img.id);
                    }
                }
                
                setToThinkingState(stateIndex) {
                    if (stateIndex < 0 || stateIndex >= this.thinkingStates.length) {
                        console.error(`‚ùå Invalid thinking state index: ${stateIndex}`);
                        return;
                    }
                    
                    const state = this.thinkingStates[stateIndex];
                    console.log(`ü§î Setting to thinking state: ${state.name}`);
                    this.applyTextureFromState(state);
                }
                
                startTalkingAnimation() {
                    if (this.isTalking) {
                        console.log('‚ö†Ô∏è Animation already running');
                        return;
                    }
                    
                    if (this.talkingStates.length === 0) {
                        console.error('‚ùå No talking states available');
                        return;
                    }
                    
                    this.isTalking = true;
                    this.isIdle = false;
                    this.currentTalkingState = 0;
                    this.talkingDirection = 1; // Start opening mouth
                    
                    console.log(`üó£Ô∏è Starting talking animation with ${this.talkingStates.length} states`);
                    
                    // Ensure image plane is visible
                    const imageMesh = this.orangePlane.getObject3D('mesh');
                    if (imageMesh) {
                        imageMesh.visible = true;
                    }
                    
                    // Start with first talking state
                    this.setToTalkingState(this.currentTalkingState);
                    
                    // Cycle through talking images forward then backward (opening/closing mouth)
                    this.talkingInterval = setInterval(() => {
                        // Check boundaries before moving
                        if (this.currentTalkingState >= this.talkingStates.length - 1 && this.talkingDirection === 1) {
                            // At max, reverse direction
                            this.talkingDirection = -1; // Start closing
                        } else if (this.currentTalkingState <= 0 && this.talkingDirection === -1) {
                            // At min, reverse direction
                            this.talkingDirection = 1; // Start opening
                        }
                        
                        // Move to next state based on direction
                        this.currentTalkingState += this.talkingDirection;
                        
                        this.setToTalkingState(this.currentTalkingState);
                    }, 200); // Fast animation for mouth movement
                }
                
                stopTalkingAnimation() {
                    if (!this.isTalking) {
                        console.log('‚ö†Ô∏è Animation not running');
                        return;
                    }
                    
                    this.isTalking = false;
                    console.log('üîá Stopping talking animation, returning to idle');
                    
                    // Clear talking interval
                    if (this.talkingInterval) {
                        clearInterval(this.talkingInterval);
                        this.talkingInterval = null;
                    }
                    
                    // Return to idle state
                    this.setToIdleState();
                }
                
                startThinkingAnimation() {
                    if (this.isThinking) {
                        console.log('‚ö†Ô∏è Thinking animation already running');
                        return;
                    }
                    
                    console.log('ü§î Starting thinking animation...');
                    this.isThinking = true;
                    this.isIdle = false;
                    
                    // Show image plane
                    const imageMesh = this.orangePlane.getObject3D('mesh');
                    if (imageMesh) {
                        imageMesh.visible = true;
                    }
                    
                    // Cycle through thinking states
                    this.thinkingInterval = setInterval(() => {
                        this.setToThinkingState(this.currentThinkingState);
                        this.currentThinkingState = (this.currentThinkingState + 1) % this.thinkingStates.length;
                    }, 800); // Slower than talking animation
                }
                
                stopThinkingAnimation() {
                    if (!this.isThinking) {
                        console.log('‚ö†Ô∏è No thinking animation running');
                        return;
                    }
                    
                    console.log('üõë Stopping thinking animation...');
                    this.isThinking = false;
                    
                    if (this.thinkingInterval) {
                        clearInterval(this.thinkingInterval);
                        this.thinkingInterval = null;
                    }
                    
                    console.log('‚úÖ Thinking animation stopped');
                }
                
                getStatus() {
                    return {
                        isTalking: this.isTalking,
                        isThinking: this.isThinking,
                        isIdle: this.isIdle,
                        currentThinkingState: this.currentThinkingState,
                        currentStateName: this.isIdle ? this.idleState.name : 
                                        this.isThinking ? this.thinkingStates[this.currentThinkingState].name :
                                        'talking-images',
                        planeSrc: this.orangePlane.getAttribute('src')
                    };
                }
            }
            
            // Initialize the animation module
            const animationModule = new TalkingAnimationModule(orangePlane);
            
            // Expose functions for external control
            function startTalkingAnimation() {
                animationModule.startTalkingAnimation();
            }
            
            function stopTalkingAnimation() {
                animationModule.stopTalkingAnimation();
            }
            
            function startThinkingAnimation() {
                animationModule.startThinkingAnimation();
            }
            
            function stopThinkingAnimation() {
                animationModule.stopThinkingAnimation();
            }
            
            // Voice recording and processing system
            let mediaRecorder = null;
            let audioChunks = [];
            let isRecording = false;
            let recordingTimer = null;
            let recordingStartTime = null;
            
            async function askQuestion() {
                if (isRecording) {
                    console.log('Stopping recording...');
                    stopRecording();
                    return;
                }
                
                try {
                    console.log('üé§ Starting voice recording...');
                    
                    // Request microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    
                    // Set up MediaRecorder
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    
                    mediaRecorder.ondataavailable = function(event) {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                            console.log(`üì¶ Collected audio chunk: ${event.data.size} bytes`);
                        }
                    };
                    
                    mediaRecorder.onstop = async function() {
                        console.log('üîä Recording stopped, processing audio...');
                        console.log(`üìä Total chunks collected: ${audioChunks.length}`);
                        
                        // Create audio blob
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        console.log(`üìä Total audio blob size: ${audioBlob.size} bytes`);
                        
                        // Convert to base64
                        const reader = new FileReader();
                        reader.onloadend = async function() {
                            const base64Audio = reader.result.split(',')[1]; // Remove data:audio/webm;base64, prefix
                            console.log(`üì§ Sending audio data: ${base64Audio.length} characters`);
                            
                            // Send to backend for processing
                            await processVoiceInput(base64Audio);
                        };
                        reader.readAsDataURL(audioBlob);
                        
                        // Stop all tracks
                        stream.getTracks().forEach(track => track.stop());
                    };
                    
                    // Start recording with timeslice to ensure we capture all data
                    mediaRecorder.start(1000); // Request data every 1 second
                    isRecording = true;
                    recordingStartTime = Date.now();
                    
                    // Show recording indicator
                    const button = document.getElementById('ask-question-btn');
                    button.textContent = currentLanguage === 'es' ? 'Detener Grabaci√≥n (0s)' : 'Stop Recording (0s)';
                    button.style.background = '#f44336';
                    
                    // Update timer every second
                    recordingTimer = setInterval(() => {
                        if (isRecording) {
                            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                            button.textContent = currentLanguage === 'es' ? `Detener Grabaci√≥n (${elapsed}s)` : `Stop Recording (${elapsed}s)`;
                            
                            // Auto-stop after 1 minute (60 seconds)
                            if (elapsed >= 60) {
                                console.log('‚è∞ Auto-stopping recording after 1 minute');
                                stopRecording();
                            }
                        }
                    }, 1000);
                    
                } catch (error) {
                    console.error('‚ùå Error accessing microphone:', error);
                    alert('Error accessing microphone. Please check permissions.');
                }
            }
            
            function stopRecording() {
                if (mediaRecorder && isRecording) {
                    console.log('üõë Stopping recording...');
                    isRecording = false;
                    
                    // Clear the timer
                    if (recordingTimer) {
                        clearInterval(recordingTimer);
                        recordingTimer = null;
                    }
                    
                    // Request final data before stopping
                    mediaRecorder.requestData();
                    
                    // Stop the recorder (this will trigger onstop)
                    mediaRecorder.stop();
                    
                    // Reset button
                    const button = document.getElementById('ask-question-btn');
                    updateButtonText(); // Use the dynamic text function
                    button.style.background = '#2196F3';
                    
                    // Start thinking animation while processing
                    console.log('ü§î Starting thinking animation...');
                    startThinkingAnimation();
                }
            }
            
            async function processVoiceInput(audioData) {
                try {
                    console.log('üì§ Sending audio to backend...');
                    
                    const response = await fetch('/api/speech/process', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            audioData: audioData,
                            sessionId: 'web_session_' + Date.now(),
                            language: currentLanguage,
                            ttsVoice: 'default',
                            ttsEngine: 'auto'
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    console.log('‚úÖ Voice processing result:', result);
                    
                    // Play the audio response
                    if (result.audioUrl) {
                        await playAudioResponse(result.audioUrl);
                    }
                    
                    // Show transcription and response
                    console.log('üìù Transcription:', result.transcription);
                    console.log('üí¨ Response:', result.response);
                    
                } catch (error) {
                    console.error('‚ùå Voice processing error:', error);
                    alert('Error processing voice input: ' + error.message);
                }
            }
            
            async function playAudioResponse(audioUrl) {
                try {
                    console.log('üîä Playing audio response:', audioUrl);
                    
                    // Stop thinking animation and start talking animation
                    stopThinkingAnimation();
                    startTalkingAnimation();
                    
                    const audio = new Audio(audioUrl);
                    
                    // Stop animation when audio ends
                    audio.onended = function() {
                        console.log('‚úÖ Audio playback completed, stopping talking animation');
                        stopTalkingAnimation();
                    };
                    
                    // Also handle errors
                    audio.onerror = function() {
                        console.error('‚ùå Audio playback error, stopping animation');
                        stopTalkingAnimation();
                    };
                    
                    await audio.play();
                    
                } catch (error) {
                    console.error('‚ùå Audio playback error:', error);
                    // Stop animation on error
                    stopTalkingAnimation();
                }
            }
            
            // Debug function
            function debugAnimation() {
                console.log('üîç Animation Debug Report');
                console.log('========================');
                console.log('Animation Module Status:', animationModule.getStatus());
                console.log('Orange Plane Element:', orangePlane);
                console.log('Orange Plane Attributes:', {
                    src: orangePlane.getAttribute('src'),
                    position: orangePlane.getAttribute('position'),
                    rotation: orangePlane.getAttribute('rotation'),
                    material: orangePlane.getAttribute('material')
                });
                
                // Manual testing - only when debug button is clicked
                console.log('üß™ Manual animation state testing...');
                console.log('Testing idle state (smile)');
                animationModule.setToIdleState();
                
                setTimeout(() => {
                    console.log('Testing thinking states');
                    animationModule.thinkingStates.forEach((state, index) => {
                        setTimeout(() => {
                            console.log(`Testing thinking state ${index + 1}: ${state.name}`);
                            animationModule.setToThinkingState(index);
                        }, index * 1000);
                    });
                    
                    setTimeout(() => {
                        console.log('Testing talking animation (images)');
                        animationModule.startTalkingAnimation();
                        
                        // Return to idle after testing
                        setTimeout(() => {
                            animationModule.stopTalkingAnimation();
                            console.log('‚úÖ Debug test completed - returned to idle');
                        }, 3000);
                    }, 2000);
                }, 1000);
            }
            
            // Language toggle functionality
            let currentLanguage = 'en';
            
            function toggleLanguage() {
                currentLanguage = currentLanguage === 'en' ? 'es' : 'en';
                const button = document.getElementById('language-toggle');
                button.textContent = currentLanguage.toUpperCase();
                updateButtonText();
            }
            
            function updateButtonText() {
                const button = document.getElementById('ask-question-btn');
                
                if (currentLanguage === 'es') {
                    button.textContent = 'Hacer Pregunta';
                } else {
                    button.textContent = 'Ask Question';
                }
            }
            
            // Initialize button text
            updateButtonText();
            
            // Expose functions globally for external control
            window.startTalkingAnimation = startTalkingAnimation;
            window.stopTalkingAnimation = stopTalkingAnimation;
            window.startThinkingAnimation = startThinkingAnimation;
            window.stopThinkingAnimation = stopThinkingAnimation;
            window.askQuestion = askQuestion;
            window.animationModule = animationModule; // Expose for console debugging
            
            if (marker) {
                // Add smoothing variables
                let lastPosition = { x: 0, y: 0, z: 0 };
                let smoothingFactor = 0.05; // Much more aggressive smoothing
                let positionHistory = [];
                const maxHistoryLength = 5;
                
                marker.addEventListener('targetFound', function() {
                    console.log('üéØ Target found! Red cube and blue sphere should be visible');
                });
                marker.addEventListener('targetLost', function() {
                    console.log('‚ùå Target lost');
                });
                
                // Add smoothing to marker position
                marker.addEventListener('componentchanged', function(event) {
                    if (event.detail.name === 'position') {
                        const currentPos = marker.getAttribute('position');
                        if (currentPos) {
                            // Add to position history
                            positionHistory.push({
                                x: parseFloat(currentPos.x),
                                y: parseFloat(currentPos.y),
                                z: parseFloat(currentPos.z)
                            });
                            
                            // Keep only recent positions
                            if (positionHistory.length > maxHistoryLength) {
                                positionHistory.shift();
                            }
                            
                            // Calculate average position
                            const avgPos = {
                                x: positionHistory.reduce((sum, pos) => sum + pos.x, 0) / positionHistory.length,
                                y: positionHistory.reduce((sum, pos) => sum + pos.y, 0) / positionHistory.length,
                                z: positionHistory.reduce((sum, pos) => sum + pos.z, 0) / positionHistory.length
                            };
                            
                            // Apply additional smoothing
                            const smoothedPos = {
                                x: lastPosition.x + (avgPos.x - lastPosition.x) * smoothingFactor,
                                y: lastPosition.y + (avgPos.y - lastPosition.y) * smoothingFactor,
                                z: lastPosition.z + (avgPos.z - lastPosition.z) * smoothingFactor
                            };
                            
                            lastPosition = smoothedPos;
                            marker.setAttribute('position', `${smoothedPos.x} ${smoothedPos.y} ${smoothedPos.z}`);
                        }
                    }
                });
            }
            
            // Check for MindAR system
            setTimeout(() => {
                if (scene && scene.systems && scene.systems['mindar-image-system']) {
                    console.log('‚úÖ MindAR system found:', scene.systems['mindar-image-system']);
                } else {
                    console.log('‚ùå MindAR system not found');
                    console.log('üîç Available systems:', scene.systems ? Object.keys(scene.systems) : 'No systems');
                }
            }, 3000);
        });
    </script>
</body>
</html>
